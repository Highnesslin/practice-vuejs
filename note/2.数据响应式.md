# 数据响应式

## 预先准备

### 响应式原理

借助 [Object.defineReactive](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)，可以对一个**对象**的某个`key`进行 **get** 和 **set** 的拦截，但有两个缺陷

1. 需要拦截对象的每个**key**，如果新添加了**key**，需要对新加的**key**执行拦截
2. 无法监听数组变化

### 三个概念 及 发布订阅模式

ps：这里只做原理简析，下文会具体提到详细的**dep 和 watcher 互相引用**等细节问题。

1. Observer<br/>
   发布者：每个对象（包含子对象）有一个 **Observer 实例**，内部存在一个 **dep**，用于管理多个**Watcher**，当数据改变时，通过 **dep** 通知 **Watcher** 进行更新
2. Dep<br/>
   发布订阅中心：内部管理多个**Watcher**
3. Watcher<br/>
   订阅者：执行组件的初始化和更新方法

### 官网的流程图

![avatar](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dba3e19f179a4e7cbf0d62402cffb756~tplv-k3u1fbpfcp-zoom-1.image)

## 从源码探究流程

初始化执行`_init`时有一个函数叫做`initState`，这便是数据响应式的入口

### initState [/src/core/instance/state.js](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L48)

- 作用：初始化 `props`、`methods`、`data`、`computed` 和 `watch`，并进行**响应式处理**
- 核心源码

  ```javascript
  const opts = vm.$options;
  // 1.props
  if (opts.props) initProps(vm, opts.props);
  // 2.methods
  if (opts.methods) initMethods(vm, opts.methods);
  // 3.data
  if (opts.data) {
    initData(vm);
  } else {
    observe((vm._data = {}), true /* asRootData */);
  }
  if (opts.computed) initComputed(vm, opts.computed);
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
  ```

  可以看到，这里对`_data`进行响应式处理，因此`_data`是一个**响应式对象**，很多**Vue 组件**都借助了这个特点获取**响应式对象**，比如**Vuex**

  这里需要特别关注`initData`方法，其**核心功能**是对`data`进行**数据响应化**处理

  ```javascript
  function initData(vm: Component) {
    const keys = Object.keys(data);
    let i = keys.length;
    while (i--) {
      const key = keys[i];

      proxy(vm, `_data`, key); // 将 响应式数据 代理到 this 上面
    }
    // 执行数据响应化
    observe(data, true /* asRootData */);
  }
  ```

### 响应式原理的入口：observe [/src/core/observer/index.js](https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L110)

- 作用：为 **数组**/**(除 VNode 以外的)对象**/ 创建 **Observer**

- 源码

  ```javascript
  export function observe(value: any, asRootData: ?boolean): Observer | void {
    if (!isObject(value) || value instanceof VNode) {
      return;
    }
    let ob: Observer | void;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (
      shouldObserve &&
      !isServerRendering() &&
      (Array.isArray(value) || isPlainObject(value)) &&
      Object.isExtensible(value) &&
      !value._isVue
    ) {
      ob = new Observer(value);
    }
    if (asRootData && ob) {
      ob.vmCount++;
    }
    return ob;
  }
  ```

  (ps:开发环境下会对`props`，`methods`校验，避免命名冲突)

  这里会有个细节，根据对象是否包含`__ob__`选择是否复用 **Observer** ，而`__ob__`是哪来的呢，其实是`new Observer`时操作的

### Observer [/src/core/observer/index.js](https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L37)

- 作用

  1. 为 **对象**/**数组** 创建 **Observer** 实例，并挂载到对象的`__ob__`属性上，
  2. 创建 **dep**，用于**数组响应式**和`set`时使用

- 核心源码

  ```javascript
  class Observer {
    constructor(value: any) {
      this.dep = new Dep();

      // 指定ob实例
      def(value, '__ob__', this);
      if (Array.isArray(value)) {
        // 覆盖原型
        if (hasProto) {
          protoAugment(value, arrayMethods);
        } else {
          copyAugment(value, arrayMethods, arrayKeys);
        }
        // 观察数组
        this.observeArray(value);
      } else {
        // 观察对象
        this.walk(value);
      }
    }
    walk(obj: Object) {
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        defineReactive(obj, keys[i]);
      }
    }

    observeArray(items: Array<any>) {
      for (let i = 0, l = items.length; i < l; i++) {
        observe(items[i]);
      }
    }
  }
  ```

  因为**数组元素**无法直接被`Object.defineProperty`拦截，所以需要单独处理。但**数组元素**可能是个**对象**，因此需要遍历数组观察里面的元素

### 观察对象：defineReactive [/src/core/observer/index.js](https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L135)

- 作用：
  1. 通过`Object.defineProperty`为**对象**的**key**进行拦截，
  2. 为对象的`key`创建**dep**，用于`key`对应的`value`发生变化时通知组件更新
- 核心源码

  ```javascript
  function defineReactive(obj: Object, key: string, val: any, customSetter?: ?Function) {
    const dep = new Dep();

    let childOb = observe(val);

    Object.defineProperty(obj, key, {
      get: function reactiveGetter() {
        const value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value;
      },
      set: function reactiveSetter(newVal) {
        const value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */
        if (newVal === value || (newVal !== newVal && value !== value)) {
          return;
        }
        // #7981: for accessor properties without setter
        // ...
        val = newVal;
        childOb = observe(newVal);
        dep.notify();
      },
    });
  }
  ```

  **getter** 负责添加依赖，**setter** 主要负责两件事

  - 1.  **内容**有变化时**通知 dep 更新 watcher**
  - 2.  **观察新设置的值(新设置的值可能也是个对象)**

  或许你会有个小疑问，执行`setter`时为什么只改形参`val`呢？

  其实这是**JavaScript** 的 **闭包** 特性，我的理解是，闭包为当前函数提供了一个作用域，每次`setter`被触发都会从当前作用域下取出变量`val`，`getter`时返回这个`val`，所以我们每次操作都值都是当前作用域下的`val`。

### 观察数组：方法覆盖 [/src/core/observer/array.js](https://github.com/vuejs/vue/blob/dev/src/core/observer/array.js)

- 作用
  - 数组有 7 个改变元素的方法，对这 7 个方法添加额外的功能
    - 1. 观察新添加的元素，实现数组内部元素数据响应式
    - 2. 取出数组身上的`__ob__`，让他的`dep`通知`watcher`更新视图，实现数组响应式
- 核心源码

  ```javascript
  // 获取数组原型
  const arrayProto = Array.prototype;
  // 克隆一份
  export const arrayMethods = Object.create(arrayProto);

  // 7个变更方法需要覆盖
  const methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];

  /**
   * Intercept mutating methods and emit events
   */
  methodsToPatch.forEach(function (method) {
    // cache original method
    // 保存原始方法
    const original = arrayProto[method];
    // 覆盖之
    def(arrayMethods, method, function mutator(...args) {
      // 1.执行默认方法
      const result = original.apply(this, args);
      // 2.变更通知
      const ob = this.__ob__;
      // 可能会有新元素加入
      let inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break;
        case 'splice':
          inserted = args.slice(2);
          break;
      }
      // 对新加入的元素做响应式
      if (inserted) ob.observeArray(inserted);
      // notify change
      // ob内部有一个dep，让它去通知更新
      ob.dep.notify();
      return result;
    });
  });
  ```

  还记得吗，在创建`Observer`实例时给对象添加了一个**dep**，这里可以取出来，调用`notify`方法通知更新，更新时会触发数组新添加元素的`getter`方法，**watcher**更新时也会再次进行依赖收集，以此完成数组的**数据响应式**

### Dep [/src/core/observer/dep.js](https://github.com/vuejs/vue/blob/dev/src/core/observer/dep.js#L13)

- 作用：
  - **Dep** 负责管理一组 **Watcher**，包括 **Watcher** 实例的**增删**及**通知更新**
- 核心源码

  ```javascript
  class Dep {
    constructor() {
      this.id = uid++;
      this.subs = [];
    }

    // 用于和watcher建立连接
    addSub(sub: Watcher) {
      this.subs.push(sub);
    }

    // 用于和watcher取消引用
    removeSub(sub: Watcher) {
      remove(this.subs, sub);
    }

    // 用于添加watcher到自己
    depend() {
      if (Dep.target) {
        Dep.target.addDep(this);
      }
    }

    // 用于通知watcher更新
    notify() {
      // stabilize the subscriber list first
      const subs = this.subs.slice();
      for (let i = 0, l = subs.length; i < l; i++) {
        subs[i].update();
      }
    }
  }
  ```

  **Dep** 和 **Watcher** 相互引用，可以通知 **Watcher** 互相添加，也可以通知 **Watcher** 互相删除，这里互相添加和互相删除都是为了处理`vm.$delete`的情况

### Watcher [/src/core/observer/watcher.js](https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js#L26)

- 作用：
  1. 分为 **render Watcher** 和 **user Watcher**，
  2. **user Watcher**用于 `watch`、`computed`，
  3. **render Watcher**用于组件**初始化**和**更新**，执行粒度是 `render` 整个组件，存在于对象观察者的**dep**中
  4. 由于**对象**存在**删除 key**的情况，如果**key**存在依赖的**watcher**，此时就需要删除掉依赖关系，所以在**watcher**内部同样需要和**dep**建立引用，用于后续的**删除 key**操作
- 核心源码

  ```javascript
  class Watcher {
    vm: Component;
    expression: string;
    cb: Function;
    id: number;
    deep: boolean;
    user: boolean;
    lazy: boolean;
    sync: boolean;
    dirty: boolean;
    active: boolean;
    deps: Array<Dep>;
    newDeps: Array<Dep>;
    depIds: SimpleSet;
    newDepIds: SimpleSet;
    before: ?Function;
    getter: Function;
    value: any;

    constructor(
      vm: Component,
      expOrFn: string | Function,
      cb: Function,
      options?: ?Object,
      isRenderWatcher?: boolean
    ) {
      this.vm = vm;
      // 用于 vm.forceUpdate
      if (isRenderWatcher) {
        vm._watcher = this;
      }
      vm._watchers.push(this);
      // options
      if (options) {
        this.deep = !!options.deep;
        this.user = !!options.user;
        this.lazy = !!options.lazy;
        this.sync = !!options.sync;
        this.before = options.before;
      } else {
        this.deep = this.user = this.lazy = this.sync = false;
      }
      this.cb = cb;
      this.id = ++uid; // uid for batching
      this.active = true;
      this.dirty = this.lazy; // for lazy watchers
      this.deps = [];
      this.newDeps = [];
      this.depIds = new Set();
      this.newDepIds = new Set();
      this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
      // parse expression for getter
      // 初始化 的时候参数2如果是一个函数，则直接赋值给getter
      if (typeof expOrFn === 'function') {
        this.getter = expOrFn;
      } else {
        this.getter = parsePath(expOrFn);
        if (!this.getter) {
          this.getter = noop;
        }
      }
      this.value = this.lazy ? undefined : this.get();
    }

    // 执行更新，重新收集依赖（初始化与更新都会再次执行这里）
    get() {
      pushTarget(this);
      let value;
      const vm = this.vm;
      try {
        value = this.getter.call(vm, vm);
      } catch (e) {
        if (this.user) {
          handleError(e, vm, `getter for watcher "${this.expression}"`);
        } else {
          throw e;
        }
      } finally {
        // 深度监听
        if (this.deep) {
          traverse(value);
        }
        popTarget();
        this.cleanupDeps();
      }
      return value;
    }

    // 添加watcher到subs
    addDep(dep: Dep) {
      const id = dep.id;
      // 相互添加引用
      if (!this.newDepIds.has(id)) {
        // watcher添加dep
        this.newDepIds.add(id);
        this.newDeps.push(dep);
        if (!this.depIds.has(id)) {
          // dep添加watcher
          dep.addSub(this);
        }
      }
    }

    // 清除依赖，更新和初始化并不会实际执行，因为newDepIds中没有内容
    cleanupDeps() {
      let i = this.deps.length;
      while (i--) {
        const dep = this.deps[i];
        if (!this.newDepIds.has(dep.id)) {
          dep.removeSub(this);
        }
      }
      let tmp = this.depIds;
      this.depIds = this.newDepIds;
      this.newDepIds = tmp;
      this.newDepIds.clear();
      tmp = this.deps;
      this.deps = this.newDeps;
      this.newDeps = tmp;
      this.newDeps.length = 0;
    }

    // 组件更新 computed watch
    update() {
      /* istanbul ignore else */
      // computed
      if (this.lazy) {
        this.dirty = true;
      } else if (this.sync) {
        this.run();
      } else {
        // 异步更新 watcher入队
        queueWatcher(this);
      }
    }

    // 同步执行的watcher，async:true
    run() {
      if (this.active) {
        // 如果是组件级别watcher，只走下面get
        const value = this.get();
        if (
          value !== this.value ||
          // Deep watchers and watchers on Object/Arrays should fire even
          // when the value is the same, because the value may
          // have mutated.
          isObject(value) ||
          this.deep
        ) {
          // set new value
          const oldValue = this.value;
          this.value = value;
          if (this.user) {
            try {
              this.cb.call(this.vm, value, oldValue);
            } catch (e) {
              handleError(e, this.vm, `callback for watcher "${this.expression}"`);
            }
          } else {
            this.cb.call(this.vm, value, oldValue);
          }
        }
      }
    }

    // 不立即触发的watcher，immediate:false
    evaluate() {
      this.value = this.get();
      this.dirty = false;
    }

    // 和 watcher 互相引用
    depend() {
      let i = this.deps.length;
      while (i--) {
        this.deps[i].depend();
      }
    }

    // 取消监听，和 watcher 互相删除 引用
    teardown() {
      if (this.active) {
        // remove self from vm's watcher list
        // this is a somewhat expensive operation so we skip it
        // if the vm is being destroyed.
        if (!this.vm._isBeingDestroyed) {
          remove(this.vm._watchers, this);
        }
        let i = this.deps.length;
        while (i--) {
          this.deps[i].removeSub(this);
        }
        this.active = false;
      }
    }
  }
  ```

  即使只选取了 Watcher 的核心源码，但内容依然很多，主要包括重新收集依赖的过程，抛开这些不谈的化，其实**Watcher**只有初始化时一次更新，以及后续更新使用的`update`方法。

## 流程梳理

1. **Vue**初始化时调用`this._init`，其中`initState`方法用于初始化**响应式数据**
2. 首先将`_data`代理到实例上，方便开发者通过`this`调用，然后对`_data`进行响应式处理，每个被观察的`value`都多了一个`__ob__`属性
3. 每个对象拥有一个**dep**，用于**数组**和`Vue.set`使用，每个**key**也拥有一个**dep**，`getter`时收集依赖（watcher），`setter`时通知依赖（watcher）更新
4. 对于数组采用**方法覆盖**的方法，**7 个方法**在执行时追加一个额外的操作，观察新增的元素，然后让数组的`__ob__`通知**watcher**进行更新

## 总结与思考

1. **dep**和**watcher** 的关系为什么设计成多对多？<br>

   - 首先要明白的概念是，**watcher**包含**render Watcher**和**user watcher**，
   - 其次，一个**key**拥有一个**dep**，
     - 一个**key**可能通过**props**绑定给多个组件，这就有多个**render Watcher**
     - 如果在组件中使用了`computed`、`watch`，这就又添加了**user Watcher**
     - 到这里，**dep**和**watcher**是一对多
   - Vue2 很重要的一点是，**render Watcher**的更新粒度是整个组件，对于一个组件，通常有多个可以触发更新的 key，又因为一个**key**一个**dep**，这种情况下**dep**和**watcher**是多对一的关系
   - 所以综合上面两种情况，**dep**和**watcher**被设计成**多对多**的关系

2. 一个**key**需要一个**dep**，用于触发**render Watcher**这个我明白，为什么一个对象还需要一个**key**呢？<br>
   用于`Vue.set`和数组更新使用

3. 为什么需要`Vue.set`，其原理是什么？<br>

   - 1. 首先对新添加的 **key** 进行监听，经过`defineReactive`方法，首先新加入的元素会变成响应式，其次内部创建了一个**dep**
   - 2. 取出对象身上的 **dep**，调用 `notify` 方法，通知 **Watcher** 更新视图，在**更新视图**时会再次走到`get`方法(用于初始化和更新时调用)，将当前**Watcher**收到新增 **key** 的 **dep** 中，完成**依赖收集**

4. 综合**数据响应式原理**，感觉最复杂的部分在于处理 **数组** 和 **新增 key** 的情况，处理这两种情况的大量逻辑都在**Watcher**中，导致**Watcher**的源码读起来很麻烦，这也是后来**Vue3**着重优化的一部分。后续专门整理下**Vue3**的变化以作对比 🚩
