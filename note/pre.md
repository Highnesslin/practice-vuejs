# 写在前面

&emsp;&emsp;**Vue3**发布已有 9 个月，相比**Vue2**确实做了太多优化，于是想着重新再仔细全面地研究一下**Vue2**源码，然后对比**Vue3**做个整理，方便以后复习查阅。<br>
so，今天就从 **Vue2** 开始吧

# 带给我的收获与思考

1. 大量设计模式的使用

   - 发布订阅模式：**数据响应式**
   - 工厂模式：`createPatchFunction`

2. 闭包

   1. **解析组件模板**： 使用了闭包作为缓存，为了重复解析
   2. `cached`：使用闭包缓存函数
   3. `createPatchFunction`： 把很多更新用的函数作为闭包
   4. `defineReactive`：闭包作用域内的变量`val`

3. 方法覆盖（扩展）<br>
   数组响应式、`$mount`方法跨平台

4. 精巧的工具方法<br>
   &emsp;&emsp;诸如**类型校验**、**代理**、**密闭对象**、**冻结对象**、**检查是否是原始值**、**extend**、**只执行一次的函数**等等，内容太多，看来要单独整理一篇文章了。

5. 微任务的妙用<br>
   **异步更新策略**借助的就是浏览器的**事件循环**，**同步任务**执行完毕后会**刷新微任务队列**。
   让我想到工作中有这么一个场景，当 **websocket** 推送数据后，页面关联的图表会重新`render`，每个图表的`render`都相对耗时，同步执行会导致每次循环都等图表渲染结束才进行下一次循环，造成页面暂时的卡顿。于是我们将`render`放到微任务中处理，等循环的同步任务结束后会自动执行微任务队列，实现了页面优化。

6. 和**react**旧**diff**的不同
   **Vue2**的**diff**与**react Fiber**之前的**diff**还是很像的，区别是**Vue2**的**diff**过程带有一点点**智能**，表现为会优先处理 web 场景**常见的情况**，即向列表头部添加元素、向列表尾部添加元素，列表的倒叙排列、升序排列

7. PS：在读源码时发现一个`initProxy`方法，里面使用了**es6**的`proxy`，也就是现在**Vue3**着重优化数据响应式的方案，但该方法只在**开发环境**下使用了一次，莫非当时就有了**proxy**代替**Object.defineProperty**的想法啦？
