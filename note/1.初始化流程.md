# 初始化流程

研究源码的第一步就是从**初始化**入手，但这也是最容易劝退的一个环节，一开始可以先在脑海中留个印象，因为后续的每个流程基本都会回到**初始化**的某个过程继续深究。

不过呢，这毕竟是一篇整理性的文章，每个环节都要全面覆盖，所以第一次阅读这部分可以跳着看，细节不关注，等到最后再回来回顾。

## 从源码探究流程

首先找到**入口**，`/src/platforms/web/`

- entry-compiler.js
- entry-runtime-with-compiler.js
- entry-runtime.js
- entry-server-basic-renderer.js
- entry-server-renderer.js

`entry-runtime-with-compiler.js`是最全面的入口，从这个入口进入，可以获得**运行时**和**编译器**两部分内容

### 注入编译器：entry-runtime-with-compiler.js [/src/platforms/web/](https://github.com/vuejs/vue/blob/dev/src/platforms/web/entry-runtime-with-compiler.js)

- 1. 解析 `template`
- 2. `template`转`render`函数，并挂载到`options`上

这一步主要作用是获得 `render`，通常在**webpack**环境中并不需要这一步，因为**webpack**在编译阶段借助**vue-loader**就将**单文件**中的`template`转成了`render`函数

### web 运行时： [/src/platforms/web/runtime/index.js](https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/index.js)

- 1. 实现`$mount`
- 2. 挂载`__patch__`

这两个方法和 **挂载** 息息相关，在后续的初始化与更新流程会来到这两个方法。

### 定义全局 API：initGlobalAPI [/src/core/index.js](https://github.com/vuejs/vue/blob/dev/src/core/global-api/index.js#L21)

- 作用：初始化 Vue 的静态方法，
  - **Vue.util** 中的方法（`mergeOptions`，`defineReactive`）、
  - `Vue.observe`、
  - `Vue.use`、
  - `Vue.mixin`、
  - `Vue.extend`、
  - `Vue.component/directive/filter`
- 核心源码
  ```javascript
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;
  initUse(Vue); // 实现Vue.use函数
  initMixin(Vue); // 实现Vue.mixin函数
  initExtend(Vue); // 实现Vue.extend函数
  initAssetRegisters(Vue); // 注册实现Vue.component/directive/filter
  ```

### 入口： [src/core/instance/index.js](https://github.com/vuejs/vue/blob/dev/src/core/instance/index.js)

- 作用
  - 1. 定义**Vue**构造器，
  - 2. 为**Vue**实例注入`API`
- 核心源码

  ```javascript
  function Vue(options) {
    this._init(options);
  }

  initMixin(Vue); // 初始化 this._init 方法
  // 其他实例属性和方法由下面这些方法混入
  stateMixin(Vue);
  eventsMixin(Vue);
  lifecycleMixin(Vue);
  renderMixin(Vue);
  ```

  我们熟知的**实例方法**基本都来自这里

  1. stateMixin
     定义`$data`、`$props`、`$set`、`$delete`、`$watch`
  2. eventsMixin
     定义`$on`、`emit`、`off`、`once`
  3. lifecycleMixin
     定义`_update`、`$forceUpdate`、`$destory`
  4. renderMixin
     定义`$nextTick`、`_render`

     为实例注入方法，基本平时工作用都有所涉及，个人感觉非常非常重要

### this.\_init [src/core/instance/init.js](https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js#L16)

- 作用

  - 调用 `mergeOptions` 合并 `Vue.options` 和 `new Vue`传入的参数，赋值给`vm.$options`
  - 伴随着生命周期的执行，为**实例**添加属性、添加事件监听（组件通信）、初始化渲染相关、执行数据响应式等等，最后调用`$mount`将组件渲染到页面

- 核心源码

  ```javascript
  vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
  initLifecycle(vm); // 实例属性：$parent,$root,$children,$refs
  initEvents(vm); // 监听_parentListeners
  initRender(vm); // 插槽解析，$slots,$scopeSlots,  $createElement()
  callHook(vm, 'beforeCreate');
  // 接下来都是和组件状态相关的数据操作
  // inject/provide
  initInjections(vm); // 注入祖辈传递下来的数据
  initState(vm); // 数据响应式：props,methods,data,computed,watch
  initProvide(vm); // 提供给后代，用来隔代传递参数
  callHook(vm, 'created');

  // 如果设置了 el，则自动执行$mount()
  if (vm.$options.el) {
    vm.$mount(vm.$options.el);
  }
  ```

  我们熟知的**实例方法**基本都来自这里

  1. initLifecycle
     定义`vm.$parent`、`vm.$root`、`vm.$refs`、`vm.$children`
  2. initEvents
     定义`vm._events`、`updateComponentListeners(vm.$listeners)`
  3. initRender
     定义`vm._c`、`vm.$createElement`
  4. initInjections
     依次执行`resolveInject`、`defineReactive`
  5. initState
     定义`initProps`、`initMethods`、`initData`、`initComputed`、`initWatch`
  6. initProvide
     定义`vm._provide`

     同样也是定义**实例**上的属性，与之不同的是，上个过程定义的**api**大多是平时工作写业务用的，那么这个过程大多数操作都是为后续提供了方法的定义，另外`initLifecycle`中定义的属性平时写**组件库**的话很熟悉。

### 渲染的入口：$mount

开头已有介绍，现在是详细探究，分开整理的原因是，`$mount`并不是一次简单的声明，而是使用了多次方法覆盖，当初第一次看源码差点绕进去，这里特意做个提醒 🚩

#### 编译相关 [/src/platforms/web/entry-runtime-with-compiler.js](https://github.com/vuejs/vue/blob/dev/src/platforms/web/entry-runtime-with-compiler.js#L18)

该文件位于 **platforms** 下的 **web** 模块，名称为`entry-runtime-with-compiler`，意味着这是一个带着编译器的运行文件。

- 作用
  - 将 `template` 转成 **render 函数**
- 核心源码
  ```javascript
  if (!options.render) {
    // 先经过 多根/dom和字符串情况 的处理，变成单根的字符串形式
    // ...
    if (template) {
      const { render, staticRenderFns } = compileToFunctions(
        template,
        {
          outputSourceRange: process.env.NODE_ENV !== 'production',
          shouldDecodeNewlines,
          shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments,
        },
        this
      );
    }
  }
  return mount.call(this, el, hydrating);
  ```
  `template` 有两种情况，`字符串`或 `dom选择器`，但最终都会处理成字符串，如果 `template` 是多根元素，经过`compileToFunctions`处理只保留第一个节点，这也是 `template` 必须要用单根的原因

#### 渲染相关 [/src/platforms/web/runtime/index.js](https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/index.js#L37)

- 作用：
  - 1. 定义**patch**：用于执行 **patching** 算法进行更新
  - 2. 为`$mount`额外添加`mountComponent`，用于在**web 平台** **执行挂载**
- 核心源码

  ```javascript
  Vue.prototype.__patch__ = inBrowser ? patch : noop;

  Vue.prototype.$mount = function (el?: string | Element, hydrating?: boolean): Component {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
  };
  ```

#### 渲染阶段的入口：mountComponent [/src/core/instance/lifecycle.js](https://github.com/vuejs/vue/blob/dev/src/core/instance/lifecycle.js#L141)

- 作用：组件初始化和更新最重要的流程之一，给`updateComponent`赋值**更新函数**，创建**Watcher**
- 核心源码

  ```javascript
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    // ...
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(
    vm,
    updateComponent,
    noop,
    {
      before() {
        if (vm._isMounted && !vm._isDestroyed) {
          callHook(vm, 'beforeUpdate');
        }
      },
    },
    true /* isRenderWatcher */
  );
  ```

  **Watcher**分为**render Watcher**和**user Watcher**<br>
  在 Vue 中，所有的渲染都由 **render Watcher** 完成，包括初始化渲染和后续的组件更新，所以这一步结束后，组件会在页面上完成更新，

## 流程梳理

1. 首先初始化**全局**的静态方法，components、filter、directive。set、delete 等，
2. 然后定义**Vue 实例**的方法，
3. 接着执行`init`方法进行**实例**的初始化，伴随着**生命周期**的进行执行初始化属性、事件监听、数据响应式，最后调用`$mount`将组件挂载到页面上

## 总结与思考

1. 为什么搞得如此复杂？<br>
   大部分复杂的流程都是为了方便跨平台，因为**Vue2**新增了跨端开发的**Weex**，所以需要注入平台特有的方法
2. 在`mergeOptions`中发现有个监听事件绑定的操作用于组件通信时，其通信机制是怎样的？<br/>
   当前组件在`mergeOptions`时有一个属性`parentListener`用来存放父组件通过 props 绑定的事件，组件会通过`$on`将注册到自身，在使用时直接`$emit`触发即可

3. 生命周期的名称及应用：

   - 2.1. 分类列举

     - 初始化阶段：beforeCreate、created、beforeMount、mounted
     - 更新阶段：beforeUpdate、updated
     - 销毁阶段：beforeDestroy、destroyed

   - 2.2. 应用：

     - created 时，所有数据准备就绪，适合做数据获取、赋值等数据操作
     - mounted 时，$el 已生成，可以获取 dom；子组件也已挂载，可以访问它们
     - updated 时，数值变化已作用于 dom，可以获取 dom 最新状态
     - destroyed 时，组件实例已销毁，适合取消定时器等操作
